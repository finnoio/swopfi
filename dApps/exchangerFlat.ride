{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
let adminAddressPubKey1 = base58'289xpUrYrKbLjaKkqH3XNhfecukcYRaDRT3JDrvkvQRU'
let adminAddressPubKey2 = base58'289xpUrYrKbLjaKkqH3XNhfecukcYRaDRT3JDrvkvQRU'
let adminAddressPubKey3 = base58'289xpUrYrKbLjaKkqH3XNhfecukcYRaDRT3JDrvkvQRU'
let governanceAddress = Address(base58'3MS55nqhYKLbLZmRExmUN3H6RSWkr9c2VC5') 
let IdTokenA =  getStringValue(this,"assetIdTokenA")
let IdTokenB =  getStringValue(this,"assetIdTokenB")
let IdTokenShare = getStringValue(this,"share_token_id")
let dAppTokensAmountA = getIntegerValue(this, "amountTokenA")
let dAppTokensAmountB = getIntegerValue(this, "amountTokenB")
let tokenShareSupply = getIntegerValue(this,"share_token_supply")
let dAppThreshold = 80 # dAppThresholdAmount/dAppThresholdAmountDelimiter = 0.8
let dAppThresholdDelimiter = 100
let comission = 500 #comission/comissionScaleDelimiter = 0.0005
let commisionGovernance = 200 # commisionGovernance/comissionScaleDelimiter = 0.0002. 3/5 fee back to the dApp, 2/5 sends to the governance address
let comissionScaleDelimiter = 1000000
let version = "2.0.0" 
let invariant = getIntegerValue(this,"invariant")
let scaleValue3 = 1000
let scaleValue8 = 100000000
let scaleValue8Digits = 8
let scaleValue12 = 1000000000000
let scaleValue12Digits = 12
let ratioThresholdMax = 100000000
let ratioThresholdMin = 99999000
let replanishmentSlippageToleranceDelimeter = 1000
let alpha = 50 #model coef alpha = 0.15 with 2 digits
let alphaDigits = 2
let beta = 46000000 #model coef beta = 0.46 with 8 digits
let betaDigits = 8

func assetId (asset: String) ={
    if asset == "WAVES" then unit else asset.fromBase58String()
}
let assetIdTokenA = assetId(IdTokenA)
let assetIdTokenB =  assetId(IdTokenB)
let assetIdTokenShare = IdTokenShare.fromBase58String()

# skeweness =  0.5*(x/y+y/x) 
# Each fraction multiple by scaleValue in order to avoid zeroing
# During working on this fraction scaleValue8 was switched to scaleValue12. To unscale back to 8 digits added /10000
func skeweness (x: Int,y:Int) = {(fraction(scaleValue12,x,y)+fraction(scaleValue12,y,x))/2/10000}

# Calculate (x+y)*skeweness^(-alpha) + 2*(x*y)^0.5*(skeweness-beta)^alpha
func invariantCalc (x: Int,y:Int) = {
    let sk = skeweness(x,y)
    #if true then throw(toString(x) + " "+ toString(y)+" "+toString(fraction(x+y,scaleValue8,pow(sk,scaleValue8Digits,alpha,alphaDigits,8,UP))+2*fraction(pow(fraction(x,y,scaleValue8),0,5,1,scaleValue8Digits/2,DOWN),pow(sk - beta,scaleValue8Digits,alpha,alphaDigits,scaleValue8Digits,DOWN),scaleValue8))) else
    fraction(x+y,scaleValue8,pow(sk,scaleValue8Digits,alpha,alphaDigits,8,UP))+2*fraction(pow(fraction(x,y,scaleValue8),0,5,1,scaleValue8Digits/2,DOWN),pow(sk - beta,scaleValue8Digits,alpha,alphaDigits,scaleValue8Digits,DOWN),scaleValue8)
}

func calculateHowManySendTokenA(amountToSendEstimated: Int, minTokenRecieveAmount: Int, amountTokenA: Int,amountTokenB: Int, tokenReceiveAmount: Int ) ={
    let slippageValue = scaleValue8 - scaleValue8*1/10000000 # 0.000001% of slippage
    let deltaBetweenMaxAndMinSendValue = amountToSendEstimated-minTokenRecieveAmount
    let amountToSendStep1 = amountToSendEstimated - 1*deltaBetweenMaxAndMinSendValue/5
    let amountToSendStep2 = amountToSendEstimated - 2*deltaBetweenMaxAndMinSendValue/5
    let amountToSendStep3 = amountToSendEstimated - 3*deltaBetweenMaxAndMinSendValue/5
    let amountToSendStep4 = amountToSendEstimated - 4*deltaBetweenMaxAndMinSendValue/5
    let amountToSendStep5 = amountToSendEstimated - 5*deltaBetweenMaxAndMinSendValue/5
    #before start check last condition. If it wrong we can stop
    if invariantCalc(amountTokenA-amountToSendStep5,amountTokenB + tokenReceiveAmount)-invariant < 0 then throw("minTokenRecieveAmount too large.err1") else
    let invariantEstimatedRatio = fraction(invariant,scaleValue8,invariantCalc(amountTokenA-amountToSendEstimated,amountTokenB + tokenReceiveAmount))
    if invariantEstimatedRatio > slippageValue && invariantEstimatedRatio < scaleValue8 then
        amountToSendEstimated
    else 
        if invariantCalc(amountTokenA-amountToSendStep1,amountTokenB + tokenReceiveAmount)-invariant > 0 then 
            amountToSendStep1*(comissionScaleDelimiter-comission)/comissionScaleDelimiter
        else if invariantCalc(amountTokenA-amountToSendStep2,amountTokenB + tokenReceiveAmount)-invariant > 0 then 
            amountToSendStep2*(comissionScaleDelimiter-comission)/comissionScaleDelimiter
        else if invariantCalc(amountTokenA-amountToSendStep3,amountTokenB + tokenReceiveAmount)-invariant > 0 then 
            amountToSendStep3*(comissionScaleDelimiter-comission)/comissionScaleDelimiter
        else if invariantCalc(amountTokenA-amountToSendStep4,amountTokenB + tokenReceiveAmount)-invariant > 0 then 
            amountToSendStep4*(comissionScaleDelimiter-comission)/comissionScaleDelimiter
        else if invariantCalc(amountTokenA-amountToSendStep5,amountTokenB + tokenReceiveAmount)-invariant > 0 then 
            amountToSendStep5*(comissionScaleDelimiter-comission)/comissionScaleDelimiter
        else 
            throw("something went wrong while working with amountToSendStep. err2")    
}

func calculateHowManySendTokenB(amountToSendEstimated: Int, minTokenRecieveAmount: Int, amountTokenA: Int,amountTokenB: Int, tokenReceiveAmount: Int ) ={
    let slippageValue = scaleValue8 - scaleValue8*1/10000000 # 0.000001% of slippage
    let deltaBetweenMaxAndMinSendValue = amountToSendEstimated-minTokenRecieveAmount
    let amountToSendStep1 = amountToSendEstimated - 1*deltaBetweenMaxAndMinSendValue/5
    let amountToSendStep2 = amountToSendEstimated - 2*deltaBetweenMaxAndMinSendValue/5
    let amountToSendStep3 = amountToSendEstimated - 3*deltaBetweenMaxAndMinSendValue/5
    let amountToSendStep4 = amountToSendEstimated - 4*deltaBetweenMaxAndMinSendValue/5
    let amountToSendStep5 = amountToSendEstimated - 5*deltaBetweenMaxAndMinSendValue/5
    #before start check last condition. If it wrong we can stop
    if invariantCalc(amountTokenA+tokenReceiveAmount,amountTokenB - amountToSendStep5)-invariant < 0 then throw("minTokenRecieveAmount too large.err1") else
    let invariantEstimatedRatio = fraction(invariant,scaleValue8,invariantCalc(amountTokenA+tokenReceiveAmount,amountTokenB - amountToSendEstimated))
    if invariantEstimatedRatio > slippageValue && invariantEstimatedRatio < scaleValue8 then
        amountToSendEstimated
    else 
        
        if invariantCalc(amountTokenA+tokenReceiveAmount,amountTokenB - amountToSendStep1)-invariant > 0 then 
            amountToSendStep1*(comissionScaleDelimiter-comission)/comissionScaleDelimiter
        else if invariantCalc(amountTokenA+tokenReceiveAmount,amountTokenB - amountToSendStep2)-invariant > 0 then 
            amountToSendStep2*(comissionScaleDelimiter-comission)/comissionScaleDelimiter
        else if invariantCalc(amountTokenA+tokenReceiveAmount,amountTokenB - amountToSendStep3)-invariant > 0 then 
            amountToSendStep3*(comissionScaleDelimiter-comission)/comissionScaleDelimiter
        else if invariantCalc(amountTokenA+tokenReceiveAmount,amountTokenB - amountToSendStep4)-invariant > 0 then 
            amountToSendStep4*(comissionScaleDelimiter-comission)/comissionScaleDelimiter
        else if invariantCalc(amountTokenA+tokenReceiveAmount,amountTokenB - amountToSendStep5)-invariant > 0 then 
            amountToSendStep5*(comissionScaleDelimiter-comission)/comissionScaleDelimiter
        else 
        throw("something went wrong while working with amountToSendStep. err2")    
}

@Callable(contextObj)
func fund() =   {
    let paymentA = value(contextObj.payments[0])
    let paymentB = value(contextObj.payments[1])
    let assetIdReceivedA = paymentA.assetId
    let tokenReceiveAmountA = paymentA.amount
    let assetIdReceivedB = paymentB.assetId
    let tokenReceiveAmountB = paymentB.amount
    let  digitTokenA = match(assetIdReceivedA) {  
            case p:Unit=> 8
            case p:ByteVector => value(assetInfo(p)).decimals
        }
    let  digitTokenB = match(assetIdReceivedB) {  
            case p:Unit=> 8
            case p:ByteVector => value(assetInfo(p)).decimals
        }
    if (isDefined(getBoolean(this, "status"))) then
            throw("already active")
    else{
        #extract tokens name 
        let asssetNameA = match assetIdReceivedA {
            case assetIdReceivedA:Unit => "WAVES"
            case _ =>  value(assetInfo(value(assetIdReceivedA))).name
        }
        let asssetNameB = match assetIdReceivedB {
            case assetIdReceivedB:Unit => "WAVES"
            case _ =>  value(assetInfo(value(assetIdReceivedB))).name
        }
        let shareTokenName = "s" + take(asssetNameA,7) + "_" + take(asssetNameB,7)
        # we save 16 digit info with using scaleValue8Digits in pow functions. We divide /scaleValue8 to delete 8 digits and another 8 digits we define as digits in shareToken in Issue tx
        let digitsInShareToken = (digitTokenA+digitTokenB)/2
        # we save 16 digit info with using scaleValue8Digits in pow functions. We divide /scaleValue8 to delete 8 digits and another 8 digits we define as digits in shareToken in Issue tx
        let shareTokenInitialAmount =  fraction(pow(tokenReceiveAmountA,digitTokenA,5,1,digitTokenA,HALFDOWN),pow(tokenReceiveAmountB,digitTokenB,5,1,digitTokenB,HALFDOWN),pow(10,0,digitsInShareToken,0,0,HALFDOWN))
        let description = "ShareToken of SwopFi protocol for " + asssetNameA + " and " + asssetNameB + " at address " + toString(this)
        let shareTokenAssetId = calculateAssetId(Issue(shareTokenName,description,shareTokenInitialAmount,digitsInShareToken,true))
        #extract string of tokens id
        let assetIdTokenStringA = match (assetIdReceivedA) {
            case t:Unit => "WAVES" 
            case t:ByteVector => toBase58String(value(assetIdReceivedA))
          }
        let assetIdTokenStringB = match(assetIdReceivedB) {
            case t:Unit => "WAVES" 
            case t:ByteVector => toBase58String(value(assetIdReceivedB))
          }
        
        let invariantCalcualated = invariantCalc(tokenReceiveAmountA,tokenReceiveAmountB)  
        #if true then throw(toString(invariantCalcualated)) else
        [
            IntegerEntry("amountTokenA", tokenReceiveAmountA ),
            IntegerEntry("amountTokenB", tokenReceiveAmountB ),
            StringEntry("assetIdTokenA", assetIdTokenStringA),
            StringEntry("assetIdTokenB", assetIdTokenStringB),
            IntegerEntry("invariant", invariantCalcualated),
            BooleanEntry("status", true),
            IntegerEntry("comission",comission),
            IntegerEntry("comissionScaleDelimiter",comissionScaleDelimiter),
            StringEntry("version", version),
            Issue(shareTokenName,description,shareTokenInitialAmount,digitsInShareToken,true),
            ScriptTransfer(contextObj.caller, shareTokenInitialAmount, shareTokenAssetId),
            StringEntry("share_token_id", toBase58String(shareTokenAssetId)),
            IntegerEntry("share_token_supply", shareTokenInitialAmount)
        ]
    } 
}

#if someone ready to replenish in both tokens. It's necessary to bring tokens amount in proportion according to dApp state
@Callable(contextObj)
func replenishmentWithTwoToken(replanishmentSlippageTolerance: Int) = {
    let paymentA = value(contextObj.payments[0])
    let paymentB = value(contextObj.payments[1])
    let assetIdReceivedA = paymentA.assetId
    let tokenReceiveAmountA = paymentA.amount
    let assetIdReceivedB = paymentB.assetId
    let tokenReceiveAmountB = paymentB.amount
    let invariantCalcualated = invariantCalc(dAppTokensAmountA + tokenReceiveAmountA, dAppTokensAmountB + tokenReceiveAmountB)  
    if this.getBooleanValue("status") != true then throw("status: Unactive") else  
    if (assetIdReceivedA != assetIdTokenA || assetIdReceivedB != assetIdTokenB ) then throw("incorrect assets") else
    # fraction should be equal 1(multiple by 1000) if depositor replanish with proporion according to actual price
    let tokenRatio = fraction(dAppTokensAmountA,scaleValue8*scaleValue3,tokenReceiveAmountA)/fraction(dAppTokensAmountB,scaleValue8,tokenReceiveAmountB)
    if  tokenRatio < (scaleValue3*(replanishmentSlippageToleranceDelimeter - replanishmentSlippageTolerance))/replanishmentSlippageToleranceDelimeter || 
    tokenRatio > (scaleValue3*(replanishmentSlippageToleranceDelimeter + replanishmentSlippageTolerance))/replanishmentSlippageToleranceDelimeter then throw("incorrect assets amount: amounts must have the contract ratio") else 
    let shareTokenToPayAmount = fraction(tokenReceiveAmountA,tokenShareSupply,dAppTokensAmountA)
    if ( shareTokenToPayAmount == 0 ) then throw("you try replansish with very small amount") else 
    [
        Reissue(assetIdTokenShare,shareTokenToPayAmount,true),
        ScriptTransfer(contextObj.caller, shareTokenToPayAmount, assetIdTokenShare),
        IntegerEntry("share_token_supply", tokenShareSupply + shareTokenToPayAmount),
        IntegerEntry("amountTokenA", dAppTokensAmountA + tokenReceiveAmountA),
        IntegerEntry("amountTokenB", dAppTokensAmountB + tokenReceiveAmountB),
        IntegerEntry("invariant", invariantCalcualated)
    ]
}

#if someone ready to replenish in one tokens
@Callable(contextObj)
func replanishmentWithOneToken(virtualSwapTokenPay :Int,virtualSwapTokenGet :Int) =   {
    let amountTokenB = getIntegerValue(this, "amountTokenB")
    let amountTokenA = getIntegerValue(this, "amountTokenA")
    let payment = value(contextObj.payments[0])
    let assetIdReceived = payment.assetId
    let tokenReceiveAmount = payment.amount
    let slippageValueMin = scaleValue8 - scaleValue8*1/10000000 # 0.000001% of slippage
    let slippageValueMax = scaleValue8 + scaleValue8*1/10000000
    if this.getBooleanValue("status") != true then throw("status: Unactive") else
    if(assetIdReceived == assetIdTokenA) then (

            let amountVirtualReplanishTokenA = tokenReceiveAmount - virtualSwapTokenPay
            let amountVirtualReplanishTokenB = virtualSwapTokenGet
            let contractBalanceAfterVirtualSwapTokenA = amountTokenA+virtualSwapTokenPay
            let contractBalanceAfterVirtualSwapTokenB = amountTokenB - virtualSwapTokenGet

            let invariantEstimatedRatio = fraction(invariant,scaleValue8,invariantCalc(contractBalanceAfterVirtualSwapTokenA,contractBalanceAfterVirtualSwapTokenB))
            if invariantEstimatedRatio > slippageValueMin && invariantEstimatedRatio <= scaleValue8 then 
                (
                    let ratioVirtualBalanceToVirtualReplanish = fraction(contractBalanceAfterVirtualSwapTokenA,scaleValue8*scaleValue8,contractBalanceAfterVirtualSwapTokenB)
                                                                    /fraction(amountVirtualReplanishTokenA,scaleValue8,amountVirtualReplanishTokenB)
                    if ratioVirtualBalanceToVirtualReplanish < slippageValueMin || ratioVirtualBalanceToVirtualReplanish > slippageValueMax then 
                                        throw("swop with virtualSwapTokenPay and virtualSwapTokenGet possible, but ratio after virtual swap incorrect") else(
                        let ratioShareTokensInA = fraction(amountVirtualReplanishTokenA,scaleValue8,contractBalanceAfterVirtualSwapTokenA)
                        let ratioShareTokensInB =  fraction(amountVirtualReplanishTokenB,scaleValue8,contractBalanceAfterVirtualSwapTokenB)
                        let shareTokenToPayAmount = if ratioShareTokensInA <= ratioShareTokensInB then fraction(ratioShareTokensInA,tokenShareSupply,scaleValue8) else fraction(ratioShareTokensInB,tokenShareSupply,scaleValue8)
                        let invariantCalcualated = invariantCalc(amountTokenA+tokenReceiveAmount,amountTokenB)
                        [
                            Reissue(assetIdTokenShare,shareTokenToPayAmount,true),
                            ScriptTransfer(contextObj.caller, shareTokenToPayAmount, assetIdTokenShare),
                            IntegerEntry("share_token_supply", tokenShareSupply + shareTokenToPayAmount),
                            IntegerEntry("amountTokenA", dAppTokensAmountA + tokenReceiveAmount),
                            IntegerEntry("invariant", invariantCalcualated)]
                        )
                )
            else throw("incorrect virtualSwapTokenPay or virtualSwapTokenGet value")

    )
    else if (assetIdReceived == assetIdTokenB) then (

            let amountVirtualReplanishTokenB = tokenReceiveAmount - virtualSwapTokenPay
            let amountVirtualReplanishTokenA = virtualSwapTokenGet
            let contractBalanceAfterVirtualSwapTokenA = amountTokenA - virtualSwapTokenGet
            let contractBalanceAfterVirtualSwapTokenB = amountTokenB + virtualSwapTokenPay
            let invariantEstimatedRatio = fraction(invariant,scaleValue8,invariantCalc(contractBalanceAfterVirtualSwapTokenA,contractBalanceAfterVirtualSwapTokenB))
            if invariantEstimatedRatio > slippageValueMin && invariantEstimatedRatio <= scaleValue8 then 
                (
                    let ratioVirtualBalanceToVirtualReplanish = fraction(contractBalanceAfterVirtualSwapTokenA,scaleValue8*scaleValue8,contractBalanceAfterVirtualSwapTokenB)
                                                                    /fraction(amountVirtualReplanishTokenA,scaleValue8,amountVirtualReplanishTokenB)
                    if ratioVirtualBalanceToVirtualReplanish < slippageValueMin || ratioVirtualBalanceToVirtualReplanish > slippageValueMax then 
                                        throw("swop with virtualSwapTokenPay and virtualSwapTokenGet possible, but ratio after virtual swap incorrect") else(
                        let ratioShareTokensInA = fraction(amountVirtualReplanishTokenA,scaleValue8,contractBalanceAfterVirtualSwapTokenA)
                        let ratioShareTokensInB =  fraction(amountVirtualReplanishTokenB,scaleValue8,contractBalanceAfterVirtualSwapTokenB)
                        let shareTokenToPayAmount = if ratioShareTokensInA <= ratioShareTokensInB then fraction(ratioShareTokensInA,tokenShareSupply,scaleValue8) else fraction(ratioShareTokensInB,tokenShareSupply,scaleValue8)
                        let invariantCalcualated = invariantCalc(amountTokenA,amountTokenB+tokenReceiveAmount)
                        [
                            Reissue(assetIdTokenShare,shareTokenToPayAmount,true),
                            ScriptTransfer(contextObj.caller, shareTokenToPayAmount, assetIdTokenShare),
                            IntegerEntry("share_token_supply", tokenShareSupply + shareTokenToPayAmount),
                            IntegerEntry("amountTokenB", dAppTokensAmountB + tokenReceiveAmount),
                            IntegerEntry("invariant", invariantCalcualated)]
                        )
                )
            else throw("incorrect virtualSwapTokenPay or virtualSwapTokenGet value")
    )
    else throw("incorrect assets in payment")  
}

@Callable(contextObj)
func withdraw() =   {
    let payment = value(contextObj.payments[0])
    let assetIdReceived = payment.assetId
    let tokenReceiveAmount = payment.amount
    let tokensToPayA = fraction(tokenReceiveAmount,dAppTokensAmountA,tokenShareSupply)
    let tokensToPayB = fraction(tokenReceiveAmount,dAppTokensAmountB,tokenShareSupply)
    let invariantCalcualated = invariantCalc(dAppTokensAmountA - tokensToPayA, dAppTokensAmountB - tokensToPayB)    
    if this.getBooleanValue("status") != true then throw("status: Unactive") else
    [      
        IntegerEntry("amountTokenA", dAppTokensAmountA - tokensToPayA),
        IntegerEntry("amountTokenB", dAppTokensAmountB - tokensToPayB),
        IntegerEntry("share_token_supply", tokenShareSupply - tokenReceiveAmount),
        ScriptTransfer(contextObj.caller, tokensToPayA, assetIdTokenA),
        ScriptTransfer(contextObj.caller, tokensToPayB, assetIdTokenB),
        Burn(assetIdTokenShare,tokenReceiveAmount),
        IntegerEntry("invariant", invariantCalcualated)

    ]
}
@Callable(contextObj)
func exchanger( amountToSendEstimated: Int, minTokenRecieveAmount: Int ) = {
    let amountTokenB = getIntegerValue(this, "amountTokenB")
    let amountTokenA = getIntegerValue(this, "amountTokenA")
    let payment = value(contextObj.payments[0])
    let assetIdReceived = payment.assetId
    let tokenReceiveAmount = payment.amount
    if this.getBooleanValue("status") != true then throw("status: Unactive") else
    if(assetIdReceived == assetIdTokenB)
        then
        (
            let tokenSendAmountWithoutFee = calculateHowManySendTokenA(amountToSendEstimated, minTokenRecieveAmount, amountTokenA,amountTokenB, tokenReceiveAmount)
            let tokenSendAmountWithFee = fraction(tokenSendAmountWithoutFee,comissionScaleDelimiter-comission,comissionScaleDelimiter)
            let tokenSendGovernance = fraction(tokenSendAmountWithoutFee,commisionGovernance,comissionScaleDelimiter)
            let assetIdSend = assetIdTokenA
            let newAmountTokenA = amountTokenA - tokenSendAmountWithFee - tokenSendGovernance
            let newAmountTokenB = amountTokenB + tokenReceiveAmount
            let dAppThresholdAmount = fraction(dAppTokensAmountA+dAppTokensAmountB,dAppThreshold,2*dAppThresholdDelimiter)
            if newAmountTokenA <  dAppThresholdAmount || newAmountTokenB < dAppThresholdAmount then throw("balance error: new dApp tokens amount less than dAppThresholdAmount") else 
            # successful execution result is updating information about actual balance and supply into the state and transfer tokens to the caller
            [
                IntegerEntry("amountTokenA", newAmountTokenA ),
                IntegerEntry("amountTokenB",  newAmountTokenB),
                IntegerEntry("invariant", invariantCalc( amountTokenA - tokenSendAmountWithFee - tokenSendGovernance,amountTokenB + tokenReceiveAmount)),
                ScriptTransfer(contextObj.caller, tokenSendAmountWithFee, assetIdSend),
                ScriptTransfer(governanceAddress,tokenSendGovernance,assetIdSend)
            ]
        )
    else ( if (assetIdReceived == assetIdTokenA)
        then
            (
            # if true then throw(toString(fraction(invariant,10000,invariantCalc(amountTokenA + AmountToGetEstimated,amountTokenB - tokenReceiveAmount)))) else
            let tokenSendAmountWithoutFee = calculateHowManySendTokenB(amountToSendEstimated, minTokenRecieveAmount, amountTokenA,amountTokenB, tokenReceiveAmount)
            let tokenSendAmountWithFee = fraction(tokenSendAmountWithoutFee,comissionScaleDelimiter-comission,comissionScaleDelimiter)
            let tokenSendGovernance = fraction(tokenSendAmountWithoutFee,commisionGovernance,comissionScaleDelimiter)
            let assetIdSend = assetIdTokenB
            let newAmountTokenA = amountTokenA + tokenReceiveAmount
            let newAmountTokenB = amountTokenB - tokenSendAmountWithFee - tokenSendGovernance
            let dAppThresholdAmount = fraction(dAppTokensAmountA+dAppTokensAmountB,dAppThreshold,2*dAppThresholdDelimiter)
            if newAmountTokenA < dAppThresholdAmount || newAmountTokenB < dAppThresholdAmount then throw("balance error: new dApp tokens amount less than dAppThresholdAmount") else 
            # successful execution result is updating information about actual balance and supply into the state and transfer tokens to the caller
            [
            IntegerEntry("amountTokenA", newAmountTokenA),
            IntegerEntry("amountTokenB", newAmountTokenB),
            IntegerEntry("invariant", invariantCalc(amountTokenA + tokenReceiveAmount, amountTokenB - tokenSendAmountWithFee - tokenSendGovernance)),
            ScriptTransfer(contextObj.caller, tokenSendAmountWithFee, assetIdSend),
            ScriptTransfer(governanceAddress,tokenSendGovernance,assetIdSend)
            ]   
        )
    else throw("Asset is not allowed"))
}

@Callable(contextObj)
func shutdown() = {
    if contextObj.callerPublicKey == adminAddressPubKey1 ||  
       contextObj.callerPublicKey == adminAddressPubKey2 ||
       contextObj.callerPublicKey == adminAddressPubKey3 then
       [
           BooleanEntry("status", false)
       ]
    else
        throw("only adminAddress can call this function")
}

@Verifier(tx)
func verify() = {
    let adminAddressPubKey1Signed  = if(sigVerify(tx.bodyBytes, tx.proofs[0], adminAddressPubKey1  )) then 1 else 0
    let adminAddressPubKey2Signed    = if(sigVerify(tx.bodyBytes, tx.proofs[1], adminAddressPubKey2    )) then 1 else 0
    let adminAddressPubKey3Signed = if(sigVerify(tx.bodyBytes, tx.proofs[2], adminAddressPubKey3 )) then 1 else 0
    adminAddressPubKey1Signed + adminAddressPubKey2Signed + adminAddressPubKey3Signed >= 2
}
