{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
let governanceAddress = Address(base58'3MSNMcqyweiM9cWpvf4Fn8GAWeuPstxj2hK') 
let IdTokenA =  getStringValue(this,"assetIdTokenA")
let IdTokenB =  getStringValue(this,"assetIdTokenB")
let amountTokenB = getIntegerValue(this, "amountTokenB")
let amountTokenA = getIntegerValue(this, "amountTokenA")
let IdTokenShare = getStringValue(this,"share_token_id")
let tokenShareSupply = getIntegerValue(this,"share_token_supply")
let comission = 3000 #comission/comissionScaleDelimiter = 0.003
let commisionGovernance = 1200 # commisionGovernance/comissionScaleDelimiter = 0.0012
let comissionScaleDelimiter = 1000000
let version = "1.0.0" 
let scaleValue3 = 1000
let scaleValue8 = 100000000
let replanishmentSlippageToleranceDelimeter = 1000
let scaleValue8Digits = 8
func assetId (asset: String) ={
    if asset == "WAVES" then unit else asset.fromBase58String()
}

let assetIdTokenA = assetId(IdTokenA)
let assetIdTokenB =  assetId(IdTokenB)
let assetIdTokenShare = IdTokenShare.fromBase58String()

@Callable(contextObj)
func fund() = {
    let paymentA = value(contextObj.payments[0])
    let paymentB = value(contextObj.payments[1])
    let assetIdReceivedA = paymentA.assetId
    let tokenReceiveAmountA = paymentA.amount
    let assetIdReceivedB = paymentB.assetId
    let tokenReceiveAmountB = paymentB.amount
    let  digitTokenA = match(assetIdReceivedA) {  
            case p:Unit=> 8
            case p:ByteVector => value(assetInfo(p)).decimals
        }
    let  digitTokenB = match(assetIdReceivedB) {  
            case p:Unit=> 8
            case p:ByteVector => value(assetInfo(p)).decimals
        }
    if (isDefined(getBoolean(this, "status"))) then
            throw("already active")
    else{    
        let shareTokenName = "ShareT_" + takeRight(toString(this),5)
        let digitsInShareToken = (digitTokenA+digitTokenB)/2
        # calculate shareTokenInitialAmount
        let shareTokenInitialAmount =  fraction(pow(tokenReceiveAmountA,digitTokenA,5,1,digitTokenA,HALFDOWN),pow(tokenReceiveAmountB,digitTokenB,5,1,digitTokenB,HALFDOWN),pow(10,0,digitsInShareToken,0,0,HALFDOWN))
        let shareTokenAssetId = calculateAssetId(Issue(shareTokenName,shareTokenName,shareTokenInitialAmount,digitsInShareToken,true))

        let assetIdTokenStringA = match (assetIdReceivedA) {
            case t:Unit => "WAVES" 
            case t:ByteVector => toBase58String(value(assetIdReceivedA))
          }
        let assetIdTokenStringB = match(assetIdReceivedB) {
            case t:Unit => "WAVES" 
            case t:ByteVector => toBase58String(value(assetIdReceivedB))
          }          
        [
            IntegerEntry("amountTokenA", tokenReceiveAmountA ),
            IntegerEntry("amountTokenB", tokenReceiveAmountB ),
            StringEntry("assetIdTokenA", assetIdTokenStringA),
            StringEntry("assetIdTokenB", assetIdTokenStringB),
            BooleanEntry("status", true),
            IntegerEntry("comission",comission),
            IntegerEntry("comissionScaleDelimiter",comissionScaleDelimiter),
            StringEntry("version", version),
            Issue(shareTokenName,shareTokenName,shareTokenInitialAmount,digitsInShareToken,true),
            ScriptTransfer(contextObj.caller, shareTokenInitialAmount, shareTokenAssetId),
            StringEntry("share_token_id", toBase58String(shareTokenAssetId)),
            IntegerEntry("share_token_supply", shareTokenInitialAmount)
        ]
    } 
}

@Callable(contextObj)
func replenishmentWithTwoToken(replanishmentSlippageTolerance: Int) = {
    let paymentA = value(contextObj.payments[0])
    let paymentB = value(contextObj.payments[1])
    let assetIdReceivedA = paymentA.assetId
    let tokenReceiveAmountA = paymentA.amount
    let assetIdReceivedB = paymentB.assetId
    let tokenReceiveAmountB = paymentB.amount
    let dAppTokensAmountA = getIntegerValue(this, "amountTokenA")
    let dAppTokensAmountB = getIntegerValue(this, "amountTokenB")
    if (assetIdReceivedA != assetIdTokenA || assetIdReceivedB != assetIdTokenB ) then throw("incorrect assets") else
    # fraction should be equal 1(multiple by 1000) if depositor replanish with proporion according to actual price
    let tokenRatio = fraction(dAppTokensAmountA,scaleValue8*scaleValue3,tokenReceiveAmountA)/fraction(dAppTokensAmountB,scaleValue8,tokenReceiveAmountB)
    if  tokenRatio < (scaleValue3*(replanishmentSlippageToleranceDelimeter - replanishmentSlippageTolerance))/replanishmentSlippageToleranceDelimeter || 
    tokenRatio > (scaleValue3*(replanishmentSlippageToleranceDelimeter + replanishmentSlippageTolerance))/replanishmentSlippageToleranceDelimeter then throw("incorrect assets amount: amounts must have the contract ratio") else 

    let shareTokenToPayAmount = fraction(tokenReceiveAmountA,tokenShareSupply,dAppTokensAmountA)
    if ( shareTokenToPayAmount == 0 ) then throw("you try replansish with very small amount") else 
    [
        Reissue(assetIdTokenShare,shareTokenToPayAmount,true),
        ScriptTransfer(contextObj.caller, shareTokenToPayAmount, assetIdTokenShare),
        IntegerEntry("share_token_supply", tokenShareSupply + shareTokenToPayAmount),
        IntegerEntry("amountTokenA", dAppTokensAmountA + tokenReceiveAmountA),
        IntegerEntry("amountTokenB", dAppTokensAmountB + tokenReceiveAmountB)
    ]
}

#if someone ready to replenish in one tokens
# @Callable(contextObj)
# func replanishmentWithOneToken() =   {
#     let payment = value(contextObj.payments[0])
#     let assetIdReceived = payment.assetId
#     let tokenReceiveAmount = payment.amount
#     if(assetIdReceived == assetIdTokenA) then (
#         let newAmountTokenA =  amountTokenA + tokenReceiveAmount
#         let priceAtoBwith8digits = fraction(newAmountTokenA,scaleValue8,amountTokenB)
#         #sqrt(invariant_old/price_new) = sqrt(x_old/price_new)* sqrt(y_old/price_new)
#         let tokenAmountBNewPriceOldInvariant = pow(fraction(amountTokenA,amountTokenB,priceAtoBwith8digits),0,5,1,0,HALFDOWN)
#         let newTokenShareSupply = fraction(amountTokenB,tokenShareSupply,tokenAmountBNewPriceOldInvariant)
#         let shareTokenToPayAmount = newTokenShareSupply-tokenShareSupply
#         [
#         Reissue(assetIdTokenShare,shareTokenToPayAmount,true),
#         ScriptTransfer(contextObj.caller, shareTokenToPayAmount, assetIdTokenShare),
#         IntegerEntry("share_token_supply", tokenShareSupply + shareTokenToPayAmount),
#         IntegerEntry("amountTokenA", newAmountTokenA)
#         ]
#     )
#     else if (assetIdReceived == assetIdTokenB) then (
#         let newAmountTokenB =  amountTokenB + tokenReceiveAmount
#         let priceAtoBwith8digits = fraction(amountTokenA,scaleValue8,newAmountTokenB)
#         #sqrt(invariant_old/price_new) = sqrt(x_old/price_new)* sqrt(y_old/price_new)
#         let tokenAmountBNewPriceOldInvariant = pow(fraction(amountTokenA,amountTokenB,priceAtoBwith8digits),0,5,1,0,HALFDOWN)
#         let newTokenShareSupply = fraction(amountTokenB,tokenShareSupply,tokenAmountBNewPriceOldInvariant)
#         let shareTokenToPayAmount = newTokenShareSupply-tokenShareSupply
#         [
#         Reissue(assetIdTokenShare,shareTokenToPayAmount,true),
#         ScriptTransfer(contextObj.caller, shareTokenToPayAmount, assetIdTokenShare),
#         IntegerEntry("share_token_supply", tokenShareSupply + shareTokenToPayAmount),
#         IntegerEntry("amountTokenB", newAmountTokenB)
#         ]
#     )
#     else throw("incorrect assets in payment")  
# }

@Callable(contextObj)
func withdraw() =   {
    let dAppTokensAmountA = getIntegerValue(this, "amountTokenA")
    let dAppTokensAmountB = getIntegerValue(this, "amountTokenB")
    let payment = value(contextObj.payments[0])
    let assetIdReceived = payment.assetId
    let tokenReceiveAmount = payment.amount
    if assetIdTokenShare !=  assetIdReceived then throw("you need to attach share token for this dApp " + toBase58String(assetIdTokenShare)) else
    let tokensToPayA = fraction(tokenReceiveAmount,dAppTokensAmountA,tokenShareSupply)
    let tokensToPayB = fraction(tokenReceiveAmount,dAppTokensAmountB,tokenShareSupply)
    if this.getBooleanValue("status") != true then throw("status: Unactive") else
    [      
        ScriptTransfer(contextObj.caller, tokensToPayA, assetIdTokenA),
        ScriptTransfer(contextObj.caller, tokensToPayB, assetIdTokenB),
        IntegerEntry("amountTokenA", dAppTokensAmountA - tokensToPayA),
        IntegerEntry("amountTokenB", dAppTokensAmountB - tokensToPayB),
        IntegerEntry("share_token_supply", tokenShareSupply - tokenReceiveAmount),
        Burn(assetIdTokenShare,tokenReceiveAmount)
    ]
}
@Callable(contextObj)
func exchanger( minTokenRecieve: Int) = {
    let payment = value(contextObj.payments[0])
    let assetIdReceived = payment.assetId
    let tokenReceiveAmount = payment.amount
    if this.getBooleanValue("status") != true then throw("status: Unactive") else
    if(assetIdReceived == assetIdTokenB)
        then
        (
            let tokenSendAmountWithoutFee =  fraction(amountTokenA,tokenReceiveAmount,tokenReceiveAmount + amountTokenB)
            let tokenSendAmountWithFee = fraction(tokenSendAmountWithoutFee,comissionScaleDelimiter-comission,comissionScaleDelimiter)
            let tokenSendGovernance = fraction(tokenSendAmountWithoutFee,commisionGovernance,comissionScaleDelimiter)
            if(tokenSendAmountWithFee < minTokenRecieve) then(throw("Price has changed dramaticaly. minTokenRecieve too large")) else
            let assetIdSend = assetIdTokenA
            # successful execution result is updating information about actual balance and supply into the state and transfer tokens to the caller
            [
                IntegerEntry("amountTokenA", amountTokenA -  tokenSendAmountWithFee -  tokenSendGovernance),
                IntegerEntry("amountTokenB",  amountTokenB + tokenReceiveAmount),
                ScriptTransfer(contextObj.caller, tokenSendAmountWithFee, assetIdSend),
                ScriptTransfer(governanceAddress, tokenSendGovernance, assetIdSend)
            ]
        )
    else ( if (assetIdReceived == assetIdTokenA)
        then
            (
            let tokenSendAmountWithoutFee = (fraction(amountTokenB,tokenReceiveAmount,tokenReceiveAmount + amountTokenA))
            let tokenSendAmountWithFee = fraction(tokenSendAmountWithoutFee,comissionScaleDelimiter-comission,comissionScaleDelimiter)
            let tokenSendGovernance = fraction(tokenSendAmountWithoutFee,commisionGovernance,comissionScaleDelimiter)
            if(tokenSendAmountWithFee < minTokenRecieve) then(throw("Price has changed dramaticaly. minTokenRecieve too large")) else
            let assetIdSend = assetIdTokenB
            # successful execution result is updating information about actual balance and supply into the state and transfer tokens to the caller
            [
            IntegerEntry("amountTokenA", amountTokenA + tokenReceiveAmount),
            IntegerEntry("amountTokenB", amountTokenB - tokenSendAmountWithFee - tokenSendGovernance),
            ScriptTransfer(contextObj.caller, tokenSendAmountWithFee, assetIdSend),
            ScriptTransfer(governanceAddress, tokenSendGovernance, assetIdSend)
            ]   
        )
    else throw("Asset is not allowed"))
}