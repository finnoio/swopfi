{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let version = "1.0.0"

let keyVersion = "version"
let keyActive = "active"
let keyAssetIdA = "A_asset_id"
let keyAssetIdB = "B_asset_id"
let keyBalanceA = "A_asset_balance"
let keyBalanceB = "B_asset_balance"
let keyShareAssetId = "share_asset_id"
let keyShareAssetSupply = "share_asset_supply"
let keyCommission = "commission"
let keyCommissionScaleDelimiter = "commission_scale_delimiter"
let keyCommissionGovernance = "commission_governance"

let adminPubKey1 = base58'289xpUrYrKbLjaKkqH3XNhfecukcYRaDRT3JDrvkvQRU'
let adminPubKey2 = base58'289xpUrYrKbLjaKkqH3XNhfecukcYRaDRT3JDrvkvQRU'
let adminPubKey3 = base58'289xpUrYrKbLjaKkqH3XNhfecukcYRaDRT3JDrvkvQRU'

let governanceAddress = Address(base58'3MSNMcqyweiM9cWpvf4Fn8GAWeuPstxj2hK')

let assetIdA = this.getStringValue(keyAssetIdA).fromBase58String()
let assetIdB = this.getStringValue(keyAssetIdB).fromBase58String()
let balanceA = this.getIntegerValue(keyBalanceA)
let balanceB = this.getIntegerValue(keyBalanceB)
let shareAssetId = this.getStringValue(keyShareAssetId).fromBase58String()
let shareAssetSupply = this.getIntegerValue(keyShareAssetSupply)

let commission = 3000 # commission/commissionScaleDelimiter = 0.003
let commissionGovernance = 1200 # commissionGovernance/commissionScaleDelimiter = 0.0012
let commissionScaleDelimiter = 1000000

let scaleValue3 = 1000
let scaleValue8 = 100000000
let slippageToleranceDelimiter = 1000
let scaleValue8Digits = 8

func getAssetInfo(assetId: ByteVector|Unit) = match assetId {
    case id: ByteVector =>
        let stringId = id.toBase58String()
        let info = assetInfo(id).valueOrErrorMessage("Asset " + stringId + " doesn't exist")
        (stringId, info.name, info.decimals)
    case waves: Unit => ("WAVES", "WAVES", 8)
}

@Callable(i)
func init() = {
    let (pmtAmountA, pmtAssetIdA) = (i.payments[0].amount, i.payments[0].assetId)
    let (pmtAmountB, pmtAssetIdB) = (i.payments[1].amount, i.payments[1].assetId)
    let (strAssetIdA, assetNameA, decimalsA) = getAssetInfo(pmtAssetIdA)
    let (strAssetIdB, assetNameB, decimalsB) = getAssetInfo(pmtAssetIdB)

    if getBoolean(this, keyActive).isDefined() then
        throw("already active")
    else if assetIdA == assetIdB then
        throw("assets must be different")
    else {
        let shareName = "s" + assetNameA.take(7) + "_" + assetNameB.take(7)
        let shareDescription = "ShareToken of SwopFi protocol for " + assetNameA + " and " + assetNameB + " at address " + this.toString()

        let shareDecimals = (decimalsA + decimalsB) / 2
        let shareInitialSupply = fraction(
            pow(pmtAmountA, decimalsA, 5, 1, decimalsA, HALFDOWN),
            pow(pmtAmountB, decimalsB, 5, 1, decimalsB, HALFDOWN),
            pow(10, 0, shareDecimals, 0, 0, HALFDOWN)
        )
        let shareIssue = Issue(shareName, shareDescription, shareInitialSupply, shareDecimals, true)
        let shareIssueId = shareIssue.calculateAssetId()
        [
            StringEntry(keyVersion, version),
            BooleanEntry(keyActive, true),
            IntegerEntry(keyBalanceA, pmtAmountA),
            IntegerEntry(keyBalanceB, pmtAmountB),
            StringEntry(keyAssetIdA, strAssetIdA),
            StringEntry(keyAssetIdB, strAssetIdB),
            IntegerEntry(keyCommission, commission),
            IntegerEntry(keyCommissionScaleDelimiter, commissionScaleDelimiter),
            shareIssue,
            StringEntry(keyShareAssetId, shareIssueId.toBase58String()),
            IntegerEntry(keyShareAssetSupply, shareInitialSupply),
            ScriptTransfer(i.caller, shareInitialSupply, shareIssueId)
        ]
    }
}

@Callable(i)
func replenishWithTwoTokens(slippageTolerance: Int) = {
    let (pmtAmountA, pmtAssetIdA) = (i.payments[0].amount, i.payments[0].assetId)
    let (pmtAmountB, pmtAssetIdB) = (i.payments[1].amount, i.payments[1].assetId)

    # fraction should be equal 1(multiple by 1000) if depositor replenish with proportion according to actual price
    let tokenRatio = fraction(balanceA, scaleValue8 * scaleValue3, pmtAmountA)
                    / fraction(balanceB, scaleValue8, pmtAmountB)

    let ratioShareTokensInA = fraction(pmtAmountA, scaleValue8, balanceA)
    let ratioShareTokensInB = fraction(pmtAmountB, scaleValue8, balanceB)
    let shareTokenToPayAmount = min([ratioShareTokensInA, ratioShareTokensInB]).fraction(shareAssetSupply, scaleValue8)

    if this.getBooleanValue(keyActive) != true then
        throw("status: Inactive")
    else if pmtAssetIdA != assetIdA || pmtAssetIdB != assetIdB then
        throw("incorrect assets")
    else if tokenRatio < (scaleValue3 * (slippageToleranceDelimiter - slippageTolerance)) / slippageToleranceDelimiter
            || tokenRatio > (scaleValue3 * (slippageToleranceDelimiter + slippageTolerance)) / slippageToleranceDelimiter then
        throw("incorrect assets amount: amounts must have the contract ratio")
    else if shareTokenToPayAmount == 0 then
        throw("you try to replenish with very small amount")
    else [
        Reissue(shareAssetId, shareTokenToPayAmount, true),
        ScriptTransfer(i.caller, shareTokenToPayAmount, shareAssetId),
        IntegerEntry(keyShareAssetSupply, shareAssetSupply + shareTokenToPayAmount),
        IntegerEntry(keyBalanceA, balanceA + pmtAmountA),
        IntegerEntry(keyBalanceB, balanceB + pmtAmountB)
    ]
}

@Callable(i)
func withdraw() = {
    let (pmtAmount, pmtAssetId) = (i.payments[0].amount, i.payments[0].assetId)

    let amountToPayA = fraction(pmtAmount, balanceA, shareAssetSupply)
    let amountToPayB = fraction(pmtAmount, balanceB, shareAssetSupply)

    if this.getBooleanValue(keyActive) != true then
        throw("status: Inactive")
    else if pmtAssetId != shareAssetId then
        throw("you need to attach share token for this dApp " + shareAssetId.toBase58String())
    else [
        IntegerEntry(keyBalanceA, balanceA - amountToPayA),
        IntegerEntry(keyBalanceB, balanceB - amountToPayB),
        IntegerEntry(keyShareAssetSupply, shareAssetSupply - pmtAmount),
        Burn(shareAssetId, pmtAmount),
        ScriptTransfer(i.caller, amountToPayA, assetIdA),
        ScriptTransfer(i.caller, amountToPayB, assetIdB)
    ]
}

@Callable(i)
func exchange(minAmountToReceive: Int) = {
    let (pmtAmount, pmtAssetId) = (i.payments[0].amount, i.payments[0].assetId)

    func calculateFees(tokenFrom: Int, tokenTo: Int) = {
        let amountWithoutFee = fraction(tokenTo, pmtAmount, pmtAmount + tokenFrom)
        let amountWithFee = fraction(amountWithoutFee, commissionScaleDelimiter - commission, commissionScaleDelimiter)
        let governanceReward = fraction(amountWithoutFee, commissionGovernance, commissionScaleDelimiter)

        if amountWithFee < minAmountToReceive then
            throw("Price has changed dramatically. minAmountToReceive too large")
        else
            (amountWithoutFee, amountWithFee, governanceReward)
    }

    if this.getBooleanValue(keyActive) != true then
        throw("status: Inactive")
     else if pmtAssetId == assetIdA then {
        let (amountWithoutFee, amountWithFee, governanceReward) = calculateFees(balanceA, balanceB)
        let assetId = assetIdB

        # successful execution result is updating information about actual balance and supply into the state and transfer tokens to the caller
        [
            IntegerEntry(keyBalanceA, balanceA + pmtAmount),
            IntegerEntry(keyBalanceB, balanceB - amountWithFee - governanceReward),
            ScriptTransfer(i.caller, amountWithFee, assetId),
            ScriptTransfer(governanceAddress, governanceReward, assetId)
        ]
    } else if pmtAssetId == assetIdB then {
        let (amountWithoutFee, amountWithFee, governanceReward) = calculateFees(balanceB, balanceA)
        let assetId = assetIdA

        # successful execution result is updating information about actual balance and supply into the state and transfer tokens to the caller
        [
            IntegerEntry(keyBalanceA, balanceA - amountWithFee - governanceReward),
            IntegerEntry(keyBalanceB, balanceB + pmtAmount),
            ScriptTransfer(i.caller, amountWithFee, assetId),
            ScriptTransfer(governanceAddress, governanceReward, assetId)
        ]
    } else
        throw("Asset is not allowed")
}

@Callable(i)
func shutdown() = {
    if [adminPubKey1, adminPubKey2, adminPubKey3].containsElement(i.callerPublicKey) then
       [
           BooleanEntry(keyActive, false)
       ]
    else
        throw("only adminAddress can call this function")
}

@Verifier(tx)
func verify() = {
    let adminPubKey1Signed = if sigVerify(tx.bodyBytes, tx.proofs[0], adminPubKey1) then 1 else 0
    let adminPubKey2Signed = if sigVerify(tx.bodyBytes, tx.proofs[1], adminPubKey2) then 1 else 0
    let adminPubKey3Signed = if sigVerify(tx.bodyBytes, tx.proofs[2], adminPubKey3) then 1 else 0
    adminPubKey1Signed + adminPubKey2Signed + adminPubKey3Signed >= 2
}
